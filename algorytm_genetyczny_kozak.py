# -*- coding: utf-8 -*-
"""noc_innowacji_AG_TSP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11G34W8uy9GPOBNQP633OatEGV5DB_XVO

# ğŸŒƒ **Noc Innowacji UE Katowice 2022** 
# Algorytm genetyczny do problemu TSP
ğŸŒœ 22.10.2022

ğŸ“­ â¡ [*jkozak.pl*](http://www.jkozak.pl/)
---

Problem:
*   Problem TSP:
*   http://elib.zib.de/pub/mp-testdata/tsp/tsplib/tsplib.html
*   Na wejÅ›ciu: macierz odlegÅ‚oÅ›ci pomiÄ™dzy punktami.

Reprezentacja:
*   KolejnoÅ›Ä‡ miast (jedno miasto, to jeden gen), liczone o 0.

Funkcja oceny:
*   Suma odlegÅ‚oÅ›ci pomiÄ™dzy miastami

Inicjalizacja:
*   Losowanie n-osobnikÃ³w (populacja wielkoÅ›ci n)

Selekcja:
*   Turniej.

Przeszukiwanie:
*   KrzyÅ¼owanie: PMX
*   Mutacja: Inwersja

**SposÃ³b rozwiÄ…zania:**
1. WczytaÄ‡ dane z pliki i przygotowaÄ‡ macierz odlegÅ‚oÅ›ci
2. NapisaÄ‡ funkcjÄ™ losujÄ…cÄ… osobnika.
3. NapisaÄ‡ funkcjÄ™ losujÄ…cÄ… n-osobnikÃ³w, czyli caÅ‚Ä… populacjÄ™.
4. NapisaÄ‡ funkcjÄ™ sumujÄ…cÄ… odlegÅ‚oÅ›ci pomiedzy miamstami i zastosowaÄ‡ jÄ… do caÅ‚ej populacji.
5. NapisaÄ‡ selekcjÄ™ z parametrem k, gdzie z k losowych osobnikÃ³w przejdzie jeden najlepszy (o najmniejszej sumie)
6. NapisaÄ‡ krzyÅ¼owanie.
7. NapisaÄ‡ mutacjÄ™.

# Dodatkowe funkcje ğŸ› 
"""

import random

def print_individual(ind, fitness):
    print("-".join(map(str,ind)),fitness)

def print_population(pop, fitness): # pop -- populacja
    print("="*10)
    for ind, f in zip(pop,fitness): # zip iteruje po 2 listach na raz z pop zapisuje do ind a z fitness do f
        print_individual(ind,f)
    print("="*10)

"""## Inicjalizacja populacji"""

def new_individual(m): # m, to liczba miast, czyli num_of_cities
    ind = [i for i in range(m)] # osobnik ma wszystkie numety miast
    random.shuffle(ind) # mieszamy kolejnoÅ›Ä‡ tych numerÃ³w
    return ind # zwracamy nowego osobnika

def new_population(n,m): # n, to liczba osobnikÃ³w w populacji (num_of_ind); a m, to liczba miast, czyli num_of_cities
    population = [] # populacja popczÄ…tkowa jest pusta
    for _ in range(n): # n razy:
        population.append(new_individual(m)) # dodajemy nowego osobnika
    return population # zwracamy caÅ‚Ä… zainicjowanÄ… populacjÄ™

"""# Ocena osobnikÃ³w ğŸ”¢"""

def calculate_fitness(ind, distance_matrix): # ind, to osobnik, a distance_matrix, to macierz odlegÅ‚oÅ›ci wczytana z pliku
    sum_distance = 0 # Tutaj sumujemy odlegÅ‚oÅ›ci pomiÄ™dzy wszystkimi miastami
    for i in range(len(ind)-1): # przejdziemy po wszystkich indeksach osobnika, poza ostanim
        city_1 = ind[i] # wczytujemy numer pierwszego miasta
        city_2 = ind[i+1] # i drugiego miasta 
        sum_distance += distance_matrix[city_1][city_2] # odlegÅ‚oÅ›Ä‡ pomiÄ™dzy miastem "i" i "i+1", a nastÄ™pnie dodajemy do sumy
    sum_distance += distance_matrix[ind[0]][ind[-1]]
    return sum_distance

def evaluate_population(pop, distance_matrix): # pop, to caÅ‚a populacja
    fitness=[] # lista z ocenami
    for ind in pop: # dla kaÅ¼dego osobnika
        fitness.append(calculate_fitness(ind,distance_matrix)) # policz ocenÄ™ i dodaj do listy ocen
    return fitness

"""# Operacje genetyczne ğŸŒ

## Selekcja
"""

def selection(pop, fitness, k=None):
    new_population = [] # Tworzymy nowÄ… populacjÄ™ -- T, osobnikÃ³w wyselekcjonowanych
    for _ in range(len(pop)): # W nowej populacji bÄ™dzie tyle samo osobnikÃ³w, co w P, czyli len(pop)
        selected = tournament(pop, fitness, k)
        new_population.append(selected) # dodanie wybranego osobnika
    return new_population # zwracamy populacjÄ™ T

"""### Selekcja tuniejowa"""

def tournament(pop, fitness, k):
    num_of_ind = len(pop) # zapisujemy liczbÄ™ osobnikÃ³w (dla wygody)
    min_index = random.randint(0,num_of_ind-1) # Piewszy losowy osobnik jest najlepszy
    for _ in range(k-1): # Losujemy kolejnych osobnikÃ³w (w sumie bÄ™dzie i k)
        random_index = random.randint(0,num_of_ind-1) # Kolejny losowy osobnik
        if fitness[min_index]>fitness[random_index]: # JeÅ›li kolejny losowy osobnik jest lepszy, to
            min_index=random_index # zapmiÄ™tujemy go, jako najlepszego
    return pop[min_index][:] # zwracamy kopiÄ™ najlepszego z turnieju

"""## KrzyÅ¼owanie"""

def crossover(pop, pc): # pop, to populacja po selekcji, pc, to parametr krzyÅ¼owanie (czy w ogÃ³le krzyÅ¼owaÄ‡)
    new_population = [] # nowa populacja juÅ¼ po krzyÅ¼owaniu osobnikÃ³w
    for i in range(0,len(pop),2): # krok co dwa, bo krzyÅ¼ujemy parami
        # i -- "pierwszy" rodzic.
        # i+1 -- "drugi" rodzic.
        p1 = pop[i]
        p2 = pop[i+1]

        # Losujemy, czy krzyÅ¼owaÄ‡
        if random.random()<pc: # JeÅ›li wylosowana z zakresu [0,1) jest mniejsza od pc, to krzyÅ¼owaÄ‡
            c1,c2 = crossover_PMX(p1,p2) # wywoÅ‚ujemy odpowiedniÄ… metodÄ™ krzyÅ¼owania
            new_population.append(c1) # do nowej poulacji przechodzi potomek "pierwszy"
            new_population.append(c2) # do nowej poulacji przechodzi potomek "pierwszy"
        else: # jeÅ›li wiÄ™ksze, to bez krzyÅ¼owania przechodzÄ… dalej
            new_population.append(p1[:]) # do nowej poulacji przechodzi kopia rodzica "pierwszego"
            new_population.append(p2[:]) # do nowej poulacji przechodzi kopia rodzica "drugiego"

    return new_population

"""### PMX"""

def pmx_fix(parent, self_mid, mid):
    fix = [] # To bÄ™dzie zwracana czÄ™Å›Ä‡ osobnika
    for gene in parent: # Przechodzimy przez geny rodzica, ktÃ³re majÄ… zostaÄ‡ przpisane
        while gene in self_mid: # JeÅ›li taki gen istnieje juÅ¼ w Å›rodku potomka, to szukamy nowego
            gene = mid[self_mid.index(gene)] # Znajduejmy indeks genu (self_mid.index(gene)) i nowy gen, to odpowiednik w mid drugiego potomka
        fix.append(gene) # Dodajemy gen do nowej czÄ™Å›ci osobnika
    return fix

def crossover_PMX(p1,p2):
    cut1 = random.randint(1,len(p1)-2) # Pierwszy punkt przeciÄ™cia, zapewniamy, aby nie byÅ‚ skrajnie po lewej i zostaÅ‚o miejsce na drugi punkt przeciÄ™cia
    cut2 = random.randint(cut1+1,len(p1)-1) # aby byÅ‚ odsuniÄ™ty od cut1 i nie byÅ‚ skrajnie po prawej

    c1 = p1[cut1:cut2] # Å›rodek pierwszego rodzica przepisujemy do pierwszego potomka (boki bÄ™da dodane pÃ³Åºniej)
    c2 = p2[cut1:cut2] # i to samo dla 2

    prefix1 = pmx_fix(p2[:cut1], c1, c2) # WywoÅ‚ujemy funkcjÄ™, ktÃ³ra przepisze poczÄ…tek z p2 i zwrÃ³ci go w odpowiedniej kolejnoÅ›ci do wpisania w c1 (wpiszemy go pÃ³Åºnie)
    prefix2 = pmx_fix(p1[:cut1], c2, c1) # analogicznie dla c2

    postfix1 = pmx_fix(p2[cut2:], c1, c2) # To samo, ale dla koÅ„ca p2 i pÃ³Åºniej wpisania w odpowiedniej kolejnoÅ›ci w c1
    postfix2 = pmx_fix(p1[cut2:], c2, c1) # analogicznie dla c2

    c1 = prefix1 + c1 + postfix1 # ÅÄ…czymy poczÄ…tek, Å›rodek i koniec c1
    c2 = prefix2 + c2 + postfix2 # analogicznie dla c2

    return c1, c2

"""## Mutacja"""

def mutation(pop, pm): # pop, to mutowana populacja, pm, to prarametr (prawdopodobieÅ„stwo) mutacji
    # ZwrÃ³Ä‡my uwagÄ™, Å¼e w przypadku mutacji zmieniamy osobniki w populacji, a wiÄ™c nie tworzymy nowej populacji ani nowych osobnikÃ³w
    for i in range(len(pop)): # Przechodzimy przez caÅ‚Ä… populacjÄ™
        if random.random()<pm: # Losujemy, czy wykonaÄ‡ mutacjÄ™
            mutation_inv(pop[i]) # jeÅ›li tak, to aktualnego osobnika (pop[i], czyli i-tego osobnika) przekazujemy do odpowiedniej mutacji
        # JeÅ›li random.random()>=pm, czyli nie ma mutacji, to nic nie musimy robiÄ‡

"""### Inwersja"""

def mutation_inv(ind):
    cut1 = random.randint(1,len(ind)) # Losujemy pierwszy punkt inwersji
    cut2 = random.randint(1,len(ind)) # Losujemy drugi punkt inwersji
    while cut2==cut1: # DopÃ³ki punkty sÄ… takie same, to
        cut2 = random.randint(1,len(ind)) # losuj inny
    if cut1>cut2: # jeÅ›li pierwszy punkt jest wiÄ™kszy od drugiego, to
        cut1, cut2 = cut2, cut1 # je zamieÅ„ miejscami

    ind[cut1:cut2] = ind[cut2-1:cut1-1:-1]

"""# Sukcesja ğŸ†•"""

def succession(pop_P, fitness_P, pop_O, fitness_O):
    pop_P += pop_O
    fitness_P += fitness_O
    fit = [[f, i] for f,i in zip(fitness_P,range(len(fitness_P)))]
    fit.sort()
    return [pop_P[el[1]] for el in fit[:len(fit)//2]]

"""# RozwiÄ…zanie ğŸ”¥

Wczytujemy liczbÄ™ miast oraz macierz odlegÅ‚oÅ›ci pomiÄ™dzy miastami
"""

# Parametry algorytmu
num_of_ind = 100
num_of_gen = 4000 # Liczba generacji (wykonaÅ„, kolejnych populacji) algorytmu
k = int(round(0.3*num_of_ind,0))
pc = 0.95 # PrawdopodobieÅ„stwo krzyÅ¼owania
pm = 0.05 # PrawdopodobieÅ„stwo mutacji

lines = open("berlin52.txt").readlines() # Otwarcie pliku i odczytanie do listy

num_of_cities = int(lines[0]) # Pierwsza linia, to liczba miast, zmieniamy na int i zapamiÄ™tujemy
distance_matrix = [[0 for _ in range(num_of_cities)] for _ in range(num_of_cities)] # Tworzymy macierz odlegÅ‚oÅ›ci, dla wielkoÅ›ci odpowiadajÄ…cej liczbie miast i wszystko wypeÅ‚niamy zerami

row = 1 # Zaczynamy od miasta o id 1, czyli od drugiego, bo w pierwszym jest tylko 0
for line in lines[2:]: # jak wyÅ¼ej
    columns = list(map(int,line.strip().split())) # line.strip().split() -- czyÅ›cimy biaÅ‚e znaki i dzielimy na listÄ™; map(int,...) zamieniamy elementy listy na int-y
    for col in range(len(columns)): # Przechodzimy przez komulny, ale po ich indeksach, aby mÃ³c zmieniaÄ‡ wartoÅ›Ä‡ w distance_matrix
        #columns[col] # odlegÅ‚oÅ›Ä‡ pomiÄ™dzy miastem row i col
        distance_matrix[row][col] = columns[col] # do macierzy odlegÅ‚oÅ›ci w miejscu row i col wpisujemy odlegÅ‚oÅ›Ä‡ pomiÄ™dzy row i col
        distance_matrix[col][row] = columns[col] # i odbicie, bo problem jest symetryczny
    row += 1 # zwiÄ™kszamy indeks wiersza o 1

def genetic_algorithm(is_succession=True, print_info=False):
    ##########
    #
    # Tworzymy populacjÄ™ (inicjalizujemy) P (poczÄ…tkowÄ… i bazowÄ…)
    #
    ##########
    pop_P = new_population(num_of_ind,num_of_cities)

    ##########
    #
    # Oceniamy populacjÄ™ P
    #
    ##########
    fitness = evaluate_population(pop_P,distance_matrix)

    ##########
    #
    # Szukamy najlepszego w populacji poczÄ…tkowej
    #
    ##########

    # Tworzymy nowego soobnika, ktÃ³ry poczÄ…tkowo jest najlepszy
    # jest to pierwszy osobnik z populacji.
    # Nasz najlepszy osobnik, to krotka, gdzie pierwszy element, to miasta, a
    # drugi element, to odlegÅ‚oÅ›Ä‡ -- dle efektywnego porÃ³wnania potem).
    min_ind = (pop_P[0][:],fitness[0]) 
    # NastÄ™pnie idziemy przez resztÄ™ populacji, szukajÄ…c, czy nie ma lepszego.
    for i in range(1,len(pop_P)):
        if fitness[i]<min_ind[1]: # jeÅ›li ocena aktualnego (i-tego) osobnika jest lepsza (mniejsza) od oceny nalepszego, czyli min_ind[1]
            # To aktualny jest nowym najlepszym:
            min_ind = (pop_P[i][:],fitness[i])    

    print("Najlepszy po losowym:", min_ind[1])

    all_min = [min_ind[1]]
    pop_max = [max(fitness)]
    pop_avg = [sum(fitness)/num_of_ind]

    ##########
    #
    # PÄ™tla algorytmu genetycznego
    #
    ##########
    for gen in range(num_of_gen): # do warunku stopu, u nas liczba generacji
        # Selekcja
        pop_T = selection(pop_P, fitness, k) # dla czytelnoÅ›ci przypisujemy do pop_T, jednak lepiej byÅ‚oby do pop, aby system operacyjny wiedziaÅ‚, Å¼e moÅ¼e zwolniÄ‡ starÄ… pamiÄ™Ä‡ pop_P
        # KrzyÅ¼owanie
        pop_O = crossover(pop_T, pc)
        # Mutacja
        mutation(pop_O, pm)
        # Ocena nowej populacji
        fitness_O = evaluate_population(pop_O,distance_matrix)

        if is_succession:
            pop_P = succession(pop_P, fitness, pop_O, fitness_O)
        else:
            pop_P = pop_O
        fitness = evaluate_population(pop_P,distance_matrix)
        
        # Sprawdzamy, czy po wszystkich operacjach pojawiÅ‚ siÄ™ jakiÅ› nowy, najlepszy
        for i in range(num_of_ind): # Przechodzimy przez wszystkich osobnikÃ³w
            if fitness[i]<min_ind[1]: # mid_ind, to krotka, gdzie w [0] jest osobnik, a w [1] jego ocena; jeÅ›li wiÄ™c znajdziemy coÅ› o mniejszej (lepsze) ocenia, to:
                min_ind = (pop_P[i][:],fitness[i]) # to tworzymy krotkÄ™, z (kopiÄ… osobnika, jego funkcjÄ… oceny)
        
        if print_info and gen %100==0: # co 100 generacji wyÅ›wietlamy najlepszego
            print(min_ind[1])

        all_min.append(min_ind[1])
        pop_max.append(max(fitness))
        pop_avg.append(sum(fitness)/num_of_ind)
    print("Najlepszy po operacjach:", min_ind[1])

    if print_info: show_plot(all_min,pop_max,pop_avg)

    return min_ind[1]

import matplotlib.pyplot as plt
def show_plot(all_min,pop_max,pop_avg):
    ox = range(len(all_min))
    plt.plot(ox, all_min)
    plt.plot(ox, pop_max)
    plt.plot(ox, pop_avg)
    plt.show()

genetic_algorithm(False, print_info=True)

import pandas as pa
import numpy
import matplotlib.pyplot as plt
data = []
test_data = []

for is_succession in [True, False]:
    test_data = []
    for _ in range(3):
        test_data.append(genetic_algorithm(is_succession))
        print()
    data.append(test_data)

print(data)

df = pa.DataFrame(numpy.array(data))
df = df.transpose()

df.plot(kind="box")
plt.show()